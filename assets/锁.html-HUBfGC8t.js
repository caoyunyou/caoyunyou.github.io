import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as i,e as n}from"./app-B5MVoM9i.js";const o={},a=n('<h3 id="_1-自旋锁-spinlock" tabindex="-1"><a class="header-anchor" href="#_1-自旋锁-spinlock"><span>1. 自旋锁（Spinlock）</span></a></h3><p><strong>Spinlock</strong>：线程在等待锁时不会被阻塞，而是不断循环检查锁的状态。适用于等待时间短的情况，但在高并发环境下可能会导致CPU浪费。</p><h3 id="_2-互斥锁-mutex" tabindex="-1"><a class="header-anchor" href="#_2-互斥锁-mutex"><span>2. 互斥锁（Mutex）</span></a></h3><p><strong>Mutex</strong>：互斥锁确保同一时间只有一个线程能访问共享资源。线程在获取锁时，如果锁被占用，会被阻塞，直到锁被释放。</p><h4 id="条件变量-condition-variable" tabindex="-1"><a class="header-anchor" href="#条件变量-condition-variable"><span>条件变量（Condition Variable）</span></a></h4><p><strong>Condition Variable</strong>：与互斥锁一起使用，允许线程在等待某个条件时释放锁，并在条件满足时重新获取锁。用于复杂的线程间通信。</p><h3 id="_3-读写锁-read-write-lock" tabindex="-1"><a class="header-anchor" href="#_3-读写锁-read-write-lock"><span>3. 读写锁（Read-Write Lock）</span></a></h3><p><strong>Read-Write Lock</strong>：允许多个线程同时读取共享资源，但写操作是互斥的，即写锁独占。适用于读多写少的场景。</p><ul><li><strong>读锁（Read Lock）</strong>：多个读线程可以同时持有读锁。</li><li><strong>写锁（Write Lock）</strong>：只有一个写线程可以持有写锁，写锁是排他的。</li></ul><h3 id="_4-递归锁-reentrant-lock" tabindex="-1"><a class="header-anchor" href="#_4-递归锁-reentrant-lock"><span>4. 递归锁（Reentrant Lock）</span></a></h3><p><strong>Reentrant Lock</strong>：允许同一个线程多次获取同一把锁，而不会导致死锁。即锁计数器会递增，每次获取锁计数器加1，释放锁计数器减1，直到计数器为0时锁才真正释放。</p><h3 id="_5-自适应锁-adaptive-lock" tabindex="-1"><a class="header-anchor" href="#_5-自适应锁-adaptive-lock"><span>5. 自适应锁（Adaptive Lock）</span></a></h3><p><strong>Adaptive Lock</strong>：根据竞争情况自动调整锁的策略。例如，在低竞争时使用自旋锁，在高竞争时使用阻塞锁。</p><h3 id="_6-轻量级锁-lightweight-locking" tabindex="-1"><a class="header-anchor" href="#_6-轻量级锁-lightweight-locking"><span>6. 轻量级锁（Lightweight Locking）</span></a></h3><p><strong>Lightweight Locking</strong>：通过减少锁操作的开销来提高性能，例如使用CAS操作实现的锁。</p><h3 id="_7-偏向锁-biased-locking" tabindex="-1"><a class="header-anchor" href="#_7-偏向锁-biased-locking"><span>7. 偏向锁（Biased Locking）</span></a></h3><p><strong>Biased Locking</strong>：优化无竞争情况下的锁获取和释放，减少锁操作的开销。</p><h3 id="_8-升级锁-upgradeable-lock" tabindex="-1"><a class="header-anchor" href="#_8-升级锁-upgradeable-lock"><span>8. 升级锁（Upgradeable Lock）</span></a></h3><p><strong>Upgradeable Lock</strong>：允许线程首先获取读锁，如果需要写操作，再升级为写锁。通常与读写锁结合使用。</p><h3 id="_9-分段锁-segmented-lock" tabindex="-1"><a class="header-anchor" href="#_9-分段锁-segmented-lock"><span>9. 分段锁（Segmented Lock）</span></a></h3><p><strong>Segmented Lock</strong>：将数据分段，每段数据都有自己的锁，从而减少锁的竞争，提高并发性能。</p><h3 id="_10-乐观锁-optimistic-locking" tabindex="-1"><a class="header-anchor" href="#_10-乐观锁-optimistic-locking"><span>10. 乐观锁（Optimistic Locking）</span></a></h3><p><strong>Optimistic Locking</strong>：假设并发冲突少，通过版本号或时间戳在提交时检测冲突，如果有冲突则重试操作。常用于数据库系统中。</p><h3 id="_11-重量级锁-heavyweight-lock" tabindex="-1"><a class="header-anchor" href="#_11-重量级锁-heavyweight-lock"><span>11. 重量级锁（Heavyweight Lock）</span></a></h3><p><strong>Heavyweight Lock</strong>：通过操作系统提供的同步机制实现的锁，通常涉及线程阻塞和上下文切换，开销较大。</p><h3 id="_12-分布式锁-distributed-lock" tabindex="-1"><a class="header-anchor" href="#_12-分布式锁-distributed-lock"><span>12. 分布式锁（Distributed Lock）</span></a></h3><p><strong>Distributed Lock</strong>：在分布式系统中使用的锁，确保多个节点之间对共享资源的互斥访问。常见实现包括基于数据库、Redis和Zookeeper的分布式锁。</p><h3 id="_13-公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#_13-公平锁和非公平锁"><span>13. 公平锁和非公平锁</span></a></h3><p><strong>公平锁（Fair Lock）</strong>：按线程请求的顺序分配锁，避免线程饥饿。</p><p><strong>非公平锁（Non-Fair Lock）</strong>：不保证顺序，允许线程插队获取锁，通常提供更高的吞吐量。</p>',30),l=[a];function r(c,s){return t(),i("div",null,l)}const h=e(o,[["render",r],["__file","锁.html.vue"]]),g=JSON.parse('{"path":"/notes/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%94%81.html","title":"锁","lang":"zh-CN","frontmatter":{"title":"锁","description":"1. 自旋锁（Spinlock） Spinlock：线程在等待锁时不会被阻塞，而是不断循环检查锁的状态。适用于等待时间短的情况，但在高并发环境下可能会导致CPU浪费。 2. 互斥锁（Mutex） Mutex：互斥锁确保同一时间只有一个线程能访问共享资源。线程在获取锁时，如果锁被占用，会被阻塞，直到锁被释放。 条件变量（Condition Variabl...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/notes/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"曹云友的博客"}],["meta",{"property":"og:title","content":"锁"}],["meta",{"property":"og:description","content":"1. 自旋锁（Spinlock） Spinlock：线程在等待锁时不会被阻塞，而是不断循环检查锁的状态。适用于等待时间短的情况，但在高并发环境下可能会导致CPU浪费。 2. 互斥锁（Mutex） Mutex：互斥锁确保同一时间只有一个线程能访问共享资源。线程在获取锁时，如果锁被占用，会被阻塞，直到锁被释放。 条件变量（Condition Variabl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-16T08:56:52.000Z"}],["meta",{"property":"article:author","content":"曹云友"}],["meta",{"property":"article:modified_time","content":"2024-05-16T08:56:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-16T08:56:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"曹云友\\",\\"url\\":\\"https://caoyunyou.github.io\\"}]}"]]},"headers":[{"level":3,"title":"1. 自旋锁（Spinlock）","slug":"_1-自旋锁-spinlock","link":"#_1-自旋锁-spinlock","children":[]},{"level":3,"title":"2. 互斥锁（Mutex）","slug":"_2-互斥锁-mutex","link":"#_2-互斥锁-mutex","children":[]},{"level":3,"title":"3. 读写锁（Read-Write Lock）","slug":"_3-读写锁-read-write-lock","link":"#_3-读写锁-read-write-lock","children":[]},{"level":3,"title":"4. 递归锁（Reentrant Lock）","slug":"_4-递归锁-reentrant-lock","link":"#_4-递归锁-reentrant-lock","children":[]},{"level":3,"title":"5. 自适应锁（Adaptive Lock）","slug":"_5-自适应锁-adaptive-lock","link":"#_5-自适应锁-adaptive-lock","children":[]},{"level":3,"title":"6. 轻量级锁（Lightweight Locking）","slug":"_6-轻量级锁-lightweight-locking","link":"#_6-轻量级锁-lightweight-locking","children":[]},{"level":3,"title":"7. 偏向锁（Biased Locking）","slug":"_7-偏向锁-biased-locking","link":"#_7-偏向锁-biased-locking","children":[]},{"level":3,"title":"8. 升级锁（Upgradeable Lock）","slug":"_8-升级锁-upgradeable-lock","link":"#_8-升级锁-upgradeable-lock","children":[]},{"level":3,"title":"9. 分段锁（Segmented Lock）","slug":"_9-分段锁-segmented-lock","link":"#_9-分段锁-segmented-lock","children":[]},{"level":3,"title":"10. 乐观锁（Optimistic Locking）","slug":"_10-乐观锁-optimistic-locking","link":"#_10-乐观锁-optimistic-locking","children":[]},{"level":3,"title":"11. 重量级锁（Heavyweight Lock）","slug":"_11-重量级锁-heavyweight-lock","link":"#_11-重量级锁-heavyweight-lock","children":[]},{"level":3,"title":"12. 分布式锁（Distributed Lock）","slug":"_12-分布式锁-distributed-lock","link":"#_12-分布式锁-distributed-lock","children":[]},{"level":3,"title":"13. 公平锁和非公平锁","slug":"_13-公平锁和非公平锁","link":"#_13-公平锁和非公平锁","children":[]}],"git":{"createdTime":1715849812000,"updatedTime":1715849812000,"contributors":[{"name":"曹云友","email":"caoyunyou@foxmail.com","commits":1}]},"readingTime":{"minutes":2.41,"words":723},"filePathRelative":"notes/基础概念/锁.md","localizedDate":"2024年5月16日","excerpt":"<h3>1. 自旋锁（Spinlock）</h3>\\n<p><strong>Spinlock</strong>：线程在等待锁时不会被阻塞，而是不断循环检查锁的状态。适用于等待时间短的情况，但在高并发环境下可能会导致CPU浪费。</p>\\n<h3>2. 互斥锁（Mutex）</h3>\\n<p><strong>Mutex</strong>：互斥锁确保同一时间只有一个线程能访问共享资源。线程在获取锁时，如果锁被占用，会被阻塞，直到锁被释放。</p>\\n<h4>条件变量（Condition Variable）</h4>\\n<p><strong>Condition Variable</strong>：与互斥锁一起使用，允许线程在等待某个条件时释放锁，并在条件满足时重新获取锁。用于复杂的线程间通信。</p>","autoDesc":true}');export{h as comp,g as data};
