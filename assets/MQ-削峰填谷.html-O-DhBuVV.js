import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as o,e as n}from"./app-Bp6yEBi2.js";const r="/assets/%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7-BgalvnGP.jpg",p={},i=n('<h1 id="mq-削峰填谷" tabindex="-1"><a class="header-anchor" href="#mq-削峰填谷"><span>MQ-削峰填谷</span></a></h1><p><strong>场景：</strong></p><p>一般而言对于互联网项目，都可能出现高QPS的场景。</p><p>当前讨论的是由MQ来解决对应的高QPS问题。但是MQ接收方的的处理能力也是有限制的，如果上游系统不限速的发送MQ，下游系统可能因为高负荷导致服务直接被压垮。</p><p>为了避免下游系统的崩溃，常见的优化方案有两种：</p><ol><li>上游队列缓冲，限速发送</li><li>下游队列缓冲，限速执行</li></ol><p><strong>提要：</strong></p><p>MQ有两种消费模式：1.推(push)，2.拉(pull)</p><ol><li>推(Push)：服务端口主动推送消息给客户端</li><li>拉(Pull)：客户端需要主动到服务端轮询获取数据</li></ol><p><strong>什么是消峰填谷：</strong></p><p>削峰填谷采用的是消费者拉取(Pull)的方式进行MQ消费，将服务器暂时无法承载的消息堆积在MQ之中，这样流量高峰就被<strong>削减</strong>了，等QPS高峰期过去，下游系统将堆积的MQ处理慢慢消耗，这个过程就叫做<strong>填谷</strong>。整个过程让下游系统的负载维持在一定水平之内。</p><img src="'+r+'" alt="消峰填谷">',12),l=[i];function a(s,c){return e(),o("div",null,l)}const d=t(p,[["render",a],["__file","MQ-削峰填谷.html.vue"]]),M=JSON.parse('{"path":"/notes/middleware/MQ/MQ-%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7.html","title":"MQ-削峰填谷","lang":"zh-CN","frontmatter":{"description":"MQ-削峰填谷 场景： 一般而言对于互联网项目，都可能出现高QPS的场景。 当前讨论的是由MQ来解决对应的高QPS问题。但是MQ接收方的的处理能力也是有限制的，如果上游系统不限速的发送MQ，下游系统可能因为高负荷导致服务直接被压垮。 为了避免下游系统的崩溃，常见的优化方案有两种： 上游队列缓冲，限速发送 下游队列缓冲，限速执行 提要： MQ有两种消费模...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/notes/middleware/MQ/MQ-%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7.html"}],["meta",{"property":"og:site_name","content":"曹云友的博客"}],["meta",{"property":"og:title","content":"MQ-削峰填谷"}],["meta",{"property":"og:description","content":"MQ-削峰填谷 场景： 一般而言对于互联网项目，都可能出现高QPS的场景。 当前讨论的是由MQ来解决对应的高QPS问题。但是MQ接收方的的处理能力也是有限制的，如果上游系统不限速的发送MQ，下游系统可能因为高负荷导致服务直接被压垮。 为了避免下游系统的崩溃，常见的优化方案有两种： 上游队列缓冲，限速发送 下游队列缓冲，限速执行 提要： MQ有两种消费模..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-15T12:41:52.000Z"}],["meta",{"property":"article:author","content":"曹云友"}],["meta",{"property":"article:modified_time","content":"2024-05-15T12:41:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MQ-削峰填谷\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-15T12:41:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"曹云友\\",\\"url\\":\\"https://caoyunyou.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1715776912000,"updatedTime":1715776912000,"contributors":[{"name":"曹云友","email":"caoyunyou@foxmail.com","commits":1}]},"readingTime":{"minutes":1.06,"words":318},"filePathRelative":"notes/middleware/MQ/MQ-削峰填谷.md","localizedDate":"2024年5月15日","excerpt":"\\n<p><strong>场景：</strong></p>\\n<p>一般而言对于互联网项目，都可能出现高QPS的场景。</p>\\n<p>当前讨论的是由MQ来解决对应的高QPS问题。但是MQ接收方的的处理能力也是有限制的，如果上游系统不限速的发送MQ，下游系统可能因为高负荷导致服务直接被压垮。</p>\\n<p>为了避免下游系统的崩溃，常见的优化方案有两种：</p>\\n<ol>\\n<li>上游队列缓冲，限速发送</li>\\n<li>下游队列缓冲，限速执行</li>\\n</ol>\\n<p><strong>提要：</strong></p>\\n<p>MQ有两种消费模式：1.推(push)，2.拉(pull)</p>\\n<ol>\\n<li>推(Push)：服务端口主动推送消息给客户端</li>\\n<li>拉(Pull)：客户端需要主动到服务端轮询获取数据</li>\\n</ol>","autoDesc":true}');export{d as comp,M as data};
