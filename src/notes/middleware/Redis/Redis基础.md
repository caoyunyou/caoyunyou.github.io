---
title: "Redis基础"
date: 2024-04-15
---


## Redis数据类型：

### **1. String（字符串）**
- **结构**：二进制安全的字符串，最大长度为 512MB。
- **核心命令**：
    - `SET key value`：设置键值。
    - `GET key`：获取值。
    - `INCR key`：原子递增（仅限数字）。
    - `APPEND key value`：追加字符串。
    - `MSET/MGET`：批量操作。
- **应用场景**：
    - **缓存**：存储热点数据（如用户会话、配置信息）。
    - **计数器**：统计文章阅读量、点赞数（`INCR`）。
    - **分布式锁**：通过 `SET key NX EX` 实现简单锁。
    - **共享 Session**：集中管理分布式系统的用户会话。
- **注意事项**：
    - 大字符串可能导致内存碎片。
    - 使用 `MSET/MGET` 批量操作减少网络开销。

---

### **2. Hash（哈希表）**
- **结构**：键值对集合，适合存储对象属性。
- **核心命令**：
    - `HSET key field value`：设置字段值。
    - `HGET key field`：获取字段值。
    - `HGETALL key`：获取所有字段。
    - `HINCRBY key field increment`：字段值递增。
- **应用场景**：
    - **用户画像**：存储用户的姓名、年龄、积分等属性。
    - **商品信息**：存储商品详情的多字段数据。
    - **购物车管理**：以用户 ID 为键，商品 ID 为字段，数量为值。
- **注意事项**：
    - 字段数量过多时，查找效率可能下降。

---

### **3. List（列表）**
- **结构**：有序、可重复的字符串集合，支持双向操作。
- **核心命令**：
    - `LPUSH/RPUSH key value`：在头部/尾部插入元素。
    - `LPOP/RPOP key`：移除头部/尾部元素。
    - `LRANGE key start stop`：获取指定范围元素。
- **应用场景**：
    - **消息队列**：简单队列（`LPUSH` + `BRPOP`）。
    - **文章分页**：存储用户时间线或文章列表。
    - **任务调度**：异步任务的生产者-消费者模型。
- **注意事项**：
    - 不支持复杂的消息确认机制（需结合其他工具）。

---

### **4. Set（集合）**
- **结构**：无序、不重复的字符串集合，支持集合运算。
- **核心命令**：
    - `SADD key member`：添加成员。
    - `SMEMBERS key`：获取所有成员。
    - `SINTER/SUNION/SDIFF`：交集、并集、差集。
- **应用场景**：
    - **标签系统**：存储用户兴趣标签，计算共同关注。
    - **抽奖活动**：`SPOP` 随机抽取用户，保证唯一性。
    - **去重统计**：记录独立 IP 或用户 ID。
- **注意事项**：
    - 不支持排序操作。

---

### **5. Sorted Set（有序集合）**
- **结构**：有序、不重复的字符串集合，每个成员关联一个分数。
- **核心命令**：
    - `ZADD key score member`：添加成员。
    - `ZRANGE key start stop [WITHSCORES]`：按排名范围获取成员。
    - `ZCARD key`：获取成员数量。
- **应用场景**：
    - **排行榜**：游戏积分、视频热度、销量排名。
    - **延迟任务**：按执行时间排序，定时触发任务。
    - **优先级队列**：分数表示优先级，处理高优先级任务。
- **注意事项**：
    - 分数更新需重新调用 `ZADD`。

---

### **6. Bitmap（位图）**
- **结构**：基于 String 的二进制位操作，节省内存。
- **核心命令**：
    - `SETBIT key offset value`：设置位。
    - `GETBIT key offset`：获取位。
    - `BITCOUNT key`：统计 1 的个数。
- **应用场景**：
    - **用户签到**：每日签到状态用 1 bit 表示，统计连续签到天数。
    - **在线状态**：记录用户是否在线（0/1）。
    - **布隆过滤器**：快速判断元素是否存在。
- **注意事项**：
    - 位操作效率高，但需手动管理位偏移。

---

### **7. HyperLogLog（基数统计）**
- **结构**：用于统计唯一值的数量（基数），误差率约 0.81%。
- **核心命令**：
    - `PFADD key element [element ...]`：添加元素。
    - `PFCOUNT key`：统计基数。
    - `PFMERGE destKey sourceKey [sourceKey ...]`：合并多个 HyperLogLog。
- **应用场景**：
    - **独立访客统计**：统计网站 UV。
    - **去重计数**：统计独立用户访问次数。
- **注意事项**：
    - 误差率无法避免，适用于对精度要求不高的场景。

---

### **8. Geospatial（地理空间）**
- **结构**：存储经纬度数据，支持地理范围查询。
- **核心命令**：
    - `GEOADD key longitude latitude member`：添加地理位置。
    - `GEORADIUS key longitude latitude radius unit`：查询指定范围内的成员。
    - `GEOHASH key member`：获取地理坐标的编码。
- **应用场景**：
    - **附近的人**：查找附近的商户、用户。
    - **地图服务**：提供基于位置的推荐。
- **注意事项**：
    - 精度受限于地球曲率，适用于宏观范围查询。

---

### **9. Stream（流）**
- **结构**：有序、可持久化的消息队列，支持消费者组。
- **核心命令**：
    - `XADD key * field value [field value ...]`：添加消息。
    - `XREAD [GROUP group name] STREAMS key count`：读取消息。
    - `XACK/XDEL`：确认/删除消息。
- **应用场景**：
    - **消息队列**：支持复杂的消息确认和重试机制。
    - **日志聚合**：集中管理分布式系统的日志。
- **注意事项**：
    - 支持消费者组，适合分布式场景。

## 优缺点：

优点：

- 快，基于内存操作。
- 单线程，操作线程安全。其中的单线程是因为多路复用IO模型的关系，对于多个连接处理是单线程+事件驱动。具体处理并不是单线程的。
- 支持持久化

缺点：【说实话，没感觉有什么】

- 对join或其他结构化查询的支持就比较差。【但是这个本来就是k-v形式的，好像这也不叫问题】



## io多路复用

将用户socket对应的文件描述符（file description）注册进epoll，然后epoll帮你监听哪些socket上有消息到达。当某个socket可读或者可写的时候，它可以给你一个通知。只有当系统通知哪个描述符可读了，才去执行read操作，可以保证每次read都能读到有效数据。这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的复用指的是复用同一个线程。



## 应用场景：

- 缓存热点数据
- 计数操作，浏览量、点赞量等
- 简单消息队列，利用Redis自身的发布/订阅模式实现简单消息队列【后面可以玩一玩，异步处理还是很好的，做一些异步的更新操作】
- 好友关系，利用集合的一些命令、比如求交集、并集、差集等。方便搞定一些共同好友、共同爱好之类的功能
- 限速器，超点处理、限流处理等。



## Memcached和Redis的区别

- Redis只使用单核，而Memcached可以使用多核。
- Memcached数据类型单一
- Memcached不支持持久化

